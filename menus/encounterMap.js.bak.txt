/*
EncounterMap
tick speed: 1 second per real life second (*60*60 speed compared to the starmap)
default zoom distances: 1200px = 1000 miles
combat map size = 5000 miles
*/
class EncounterMap {
    constructor(encounter = new Encounter(), autoSelectObject = gameState.fleet) {
        this.starSystem = gameState.system
        this.encounter = encounter
        this.selectedObject = autoSelectObject || gameState.fleet;

        this.zoom = 1200*100*1000/MILES_PER_AU;
        this.maxZoom = this.zoom*10
        this.minZoom = this.zoom/10
        this.cameraPanLimit = encounter.mapDimensions

        this.cameraX = this.selectedObject.x;
        this.cameraY = this.selectedObject.y;
        this.mapWidth = 1200
        this.mapHeight = 600
        //this.noOrbitsAtZoom = 5000
        this.paused = true
        this.lastTickMs = Date.now()
        this.gameSecondsPerMs = 1/1000

        this.root = createElement({classNames: ['starmap-root']})
        this.infoBar = createElement({parent: this.root, classNames:['starmap-info']})
        this.controls = createElement({parent: this.root})
        this.main = createElement({parent: this.root, classNames:['starmap-main']})

        this.leftPane = createElement({parent:this.root, classNames:['starmap-left']})
        this.leftPane.style.width = this.mapWidth+'px';
        this.leftPane.style.height = this.mapHeight+'px';
        attachDragHandler(this.leftPane, (x,y)=>this.onDragMap(x,y), 5)
        attachMouseWheelHandler(this.leftPane, (direction=1)=>{
            this.adjustZoom(direction > 0 ? 1.33 : direction < 0 ? 0.66 : 1.0)
        })

        this.leftPaneBGLayer = createElement({parent:this.leftPane, classNames:['starmap-layer']})
        this.leftPaneBGLayerCvs = createElement({parent:this.leftPaneBGLayer, tag:'canvas'})
        this.leftPaneBGLayerCvs.height = this.mapHeight;
        this.leftPaneBGLayerCvs.width = this.mapWidth;
        this.leftPaneObjLayer = createElement({parent:this.leftPane, classNames:['starmap-layer']})

        this.rightPane = createElement({parent:this.root, classNames:['starmap-right']})

        this.main.appendChild(this.leftPane);
        this.main.appendChild(this.rightPane);

        this.refresh()
    }

    refresh() {
        this.rebuildLeftPaneObjLayer();
        this.refreshControls();
        this.refreshInfoBar();
        this.refreshRightPane();
        this.refreshLeftPaneObjLayer();
        this.refreshLeftPaneBGLayer();
    }

    refreshControls() {
        this.controls.innerHTML = ""
        createElement({
            parent:this.controls,
            classNames: ['starmap-buttons'],
            children: [
                createElement({tag:'button', innerHTML:this.paused ? '▶' : '⏸', onClick: () => this.togglePause(), disabled: !gameState.encounter.combatEnabled}),
                createElement({tag:'button', innerHTML:'+', onClick: () => this.adjustZoom(1.33)}),
                createElement({tag:'button', innerHTML:'-', onClick: () => this.adjustZoom(0.66)}),
                //ship info button?
                createElement({tag:'button', innerHTML:'Hail', onClick: ()=> this.onHail()})
            ]
        })
    }

    refreshInfoBar() {
        const {fleet, year} = gameState
        const {location, route} = fleet
        const destination = route?.destination
        const distance = round(route?.distance, 2)
        const endYear = route?.endYear
        const yearsRemaining = describeTimespan(endYear-year)

        this.infoBar.innerHTML = ""

        const children = [
            createElement({innerHTML: `Date: ${describeDate(year)}`}),
            createElement({innerHTML: ` | Location: ${location ? coloredName(location, false) : '(Space)'}`, onClick: ()=>this.selectObject(location)}),
            createElement({innerHTML: ` | Destination: ${destination ? coloredName(destination, false) : '(None)'}`, onClick: destination ? ()=>this.selectObject(destination) : undefined}),
            createElement({innerHTML: !destination ? '' : ` | Distance: ${distance} AU`}),
            createElement({innerHTML: !destination ? '' : ` | ETA: ${yearsRemaining}`}),
        ]

        for (const child of children) this.infoBar.appendChild(child)
    }

    rebuildLeftPaneObjLayer() {
        const {leftPaneObjLayer, encounter} = this
        const playerFleet = gameState.fleet
        const playerShips = playerFleet.ships
        const enemyFleet = encounter.fleet
        const enemyShips = enemyFleet.ships
        const ships = [...playerShips, ...enemyShips];

        leftPaneObjLayer.innerHTML = ""

        //draw lasers
        ships.forEach((ship,index)=>{
            const id = `shiplaser${index}`
            const isAllied = playerShips.includes(ship)
            createElement({
                id,
                parent: leftPaneObjLayer,
                classNames: ['starmap-line'],
                style: {
                    backgroundColor: isAllied ? 'blue' : 'red',
                },
            })
        })

        //draw objects
        ships.forEach((ship,index) => {
            //if (obj.location) return //dont display docked fleets
            const id = `ship${index}`
            const shieldId = `shipshield${index}`
            const wrapperId = `wrapper${index}`
            console.log('rebuilding a ship')
            const color = ship.graphics?.color || '#ffffff'
            createElement({
                id: wrapperId,
                parent: leftPaneObjLayer,
                classNames: ['starmap-object'],
                onClick: ()=>this.selectObject(ship),
                children: [
                    createElement({
                        id: shieldId,
                        classNames: ['starmap-circle-empty'],
                    }),
                    createElement({
                        id,
                        classNames: ['starmap-ship'],
                        style: {
                            backgroundColor: color,
                            zIndex: '99',
                        }
                    }),
                    createElement({classNames: ['starmap-label'], innerHTML: coloredName(ship)})
                ]
            })
        })
    }

    refreshLeftPaneBGLayer() {
        const {zoom, mapWidth, mapHeight, starSystem} = this
        const hw = mapWidth/2
        const hh = mapHeight/2
        const cx = this.cameraX;
        const cy = this.cameraY;
        const objs = [...starSystem.backgroundStars]
        const canvas = this.leftPaneBGLayerCvs;
        const ctx = this.leftPaneBGLayerCvs.getContext("2d");
        const mod = 2000 //hacky =/

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        objs.forEach((obj, index)=>{
            ctx.fillStyle = obj.graphics.color;
            ctx.beginPath();
            ctx.arc((mod*obj.x-cx)*zoom+hw, (mod*obj.y-cy)*zoom+hh, 1, 0, Math.PI * 2);
            ctx.fill();
        })
    }

    refreshLeftPaneObjLayer() {
        const {zoom, mapWidth, mapHeight, encounter, noOrbitsAtZoom} = this
        const playerFleet = gameState.fleet
        const playerShips = playerFleet.ships
        const enemyFleet = encounter.fleet
        const enemyShips = enemyFleet.ships
        const ships = [...playerShips, ...enemyShips];

        const hw = mapWidth/2
        const hh = mapHeight/2
        const cx = this.cameraX;
        const cy = this.cameraY;

        /*const shipPaths = ships.map(ship=>{
            if (ship.destinationX == undefined || ship.destinationY == undefined) return null
            return new Path(ship.x, ship.y, ship.destinationX, ship.destinationY)
        })*/

        //draw ship lasers
        ships.forEach( (ship, index) => {
            const id = `shiplaser${index}`
            let gfx = this.leftPaneObjLayer.querySelector('#'+id)
            if (!gfx) return
            if (!ship.firingTimeRemaining || !ship.target) {
                gfx.style.display = 'none'
                return
            }
            const laserPath = new Path(ship.x, ship.y, ship.target.x, ship.target.y)
            let {startX, startY, distance, angleDeg} = laserPath
            applyStyle(gfx, {
                display: '',
                width: `${distance * zoom}px`,
                transform: `rotate(${angleDeg}deg)`,
                left: ((startX-cx) * zoom + hw) + 'px',
                top: ((startY-cy) * zoom + hh) + 'px',
            })
        })

        //draw objects
        ships.forEach( (ship, index) => {
            //if (obj.location) return //dont display docked fleets
            const id = `ship${index}`
            const shieldId = `shipshield${index}`
            const wrapperId = `wrapper${index}`
            let gfx = this.leftPaneObjLayer.querySelector('#'+id)
            if (!gfx) return
            let shieldGfx = this.leftPaneObjLayer.querySelector('#'+shieldId)
            let wrapperGfx = this.leftPaneObjLayer.querySelector('#'+wrapperId)
            if (!gfx || !wrapperGfx) return
            const size = Math.max(12, (ship.graphics?.size || 0) * zoom / EARTH_RADII_PER_AU);
            const shieldsRatio = ship.shields[0]/ship.shields[1]
            const shield255 = Math.round(255*shieldsRatio)
            const hullRatio = 0.5 + (0.5*ship.hull[0]/ship.hull[1])

            applyStyle(gfx, {
                width: (size) + 'px',
                height: (size) + 'px',
                transform: `rotate(${ship.calcAngleDeg()}deg)`,
            })
            applyStyle(shieldGfx, {
                width: (size+4) + 'px',
                height: (size+4) + 'px',
                borderColor: `rgba(0,${shield255},${shield255})`
            })
            applyStyle(gfx, {
                width: (size) + 'px',
                height: (size) + 'px',
                filter: `brightness(${hullRatio})`,
                transform: `rotate(${ship.calcAngleDeg()}deg)`,
            })
            applyStyle(wrapperGfx, {
                left: ((ship.x-cx) * zoom + hw) + 'px',
                top: ((ship.y-cy) * zoom + hh) + 'px',
            })
        })
    }

    refreshRightPane() {
        this.rightPane.innerHTML = '';
        if (!this.selectedObject) {
            this.rightPane.textContent = '(Select an object on the map.)';
            return;
        }
        createElement({parent:this.rightPane, tag:'h2', innerHTML: coloredName(this.selectedObject)})
    }

    selectObject(obj) {
        console.log('selected:',obj)
        this.selectedObject = obj;
        this.cameraX = obj.x;
        this.cameraY = obj.y;
        this.refresh();
    }

    onDragMap(x = 0, y = 0) {
        this.cameraX -= x/this.zoom
        this.cameraY -= y/this.zoom
        console.log('camera x,y vs limit:',this.cameraX,this.cameraY,this.cameraPanLimit)
        this.cameraX = Math.min(this.cameraPanLimit, Math.max(-this.cameraPanLimit, this.cameraX))
        this.cameraY = Math.min(this.cameraPanLimit, Math.max(-this.cameraPanLimit, this.cameraY))
        this.refreshLeftPaneBGLayer()
        this.refreshLeftPaneObjLayer()
    }

    adjustZoom(factor) {
        this.zoom *= factor;
        this.zoom = Math.min(this.maxZoom, this.zoom)
        this.zoom = Math.max(this.minZoom, this.zoom)
        this.refreshLeftPaneBGLayer()
        this.refreshLeftPaneObjLayer();
    }

    togglePause(newPausedState) {
        this.paused = (newPausedState !== undefined ? newPausedState : !this.paused)
        if (!this.paused) {
            this.lastTickMs = Date.now()
            this.tick()
        }
        this.refresh() //always do first refresh, as fleets launch during pause/unpause
    }

    tick() {
        if (this.paused || !gameState.encounter.combatEnabled) return

        const currentTime = Date.now()
        const elapsedMs = currentTime - this.lastTickMs
        this.lastTickMs = currentTime
        const elapsedSeconds = elapsedMs * this.gameSecondsPerMs;
        gameState.encounter.tick(elapsedSeconds)

        this.refreshLeftPaneObjLayer()
        this.refreshInfoBar()

        requestAnimationFrame(()=>this.tick())
    }

    onHail() {
        if (gameState.encounter.combatEnabled) {
            //surrender logic
        }
        else gameState.encounter.encounterType.onStart()
    }
}

function startEncounter() {
    const encounter = generateEncounter()
    gameState.encounter = encounter

    //randomize ship locations
    const playerFleet = gameState.fleet
    const playerShips = playerFleet.ships
    const enemyFleet = encounter.fleet
    const enemyShips = enemyFleet.ships
    const spawnDistance = encounter.mapDimensions*0.25

    for (const ship of playerShips) {
        const [x,y] = rotatePoint(-rng(spawnDistance, 0, false), 0, 0, 0, rng(Math.PI/2, -Math.PI/2, false))
        ship.resetCombatVars()
        ship.x = x
        ship.y = y
        const randomTarget = rndMember(enemyShips)
        ship.angle = new Path(ship.x, ship.y, randomTarget.x, randomTarget.y).angle
    }
    for (const ship of enemyShips) {
        const [x,y] = rotatePoint(rng(spawnDistance, 0, false), 0, 0, 0, rng(Math.PI/2, -Math.PI/2, false))
        ship.resetCombatVars()
        ship.x = x
        ship.y = y
        ship.graphics.color = 'orange'
        const randomTarget = rndMember(playerShips)
        ship.angle = new Path(ship.x, ship.y, randomTarget.x, randomTarget.y).angle
    }

    showModal(encounter.encounterType.name, encounter.encounterType.description, [['Ok', ()=>{
        showEncounterMap()
        encounter.encounterType.onStart()
    }]])
}

function endEncounter() {
    gameState.encounter = undefined
    showStarMap()
}

function showEncounterMap() {
    const encounterMap = new EncounterMap(gameState.encounter, gameState.fleet.ships[0])
    showMap(encounterMap)
}

function startCombat() {
    gameState.encounter.combatEnabled = true;
    closeModal()
    currentMap.togglePause(false)
}

function endCombat(playerVictory = false) {
    gameState.encounter.combatEnabled = false;
    if (playerVictory) {
        //showVictoryMenu()
    }
    else gameState.encounter.encounterType.afterDefeated()
}